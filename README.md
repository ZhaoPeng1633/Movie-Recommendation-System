# Movie-Recommendation-System
这个电影推荐系统使用了PyQt5作为图形化界面的工具，同时使用了MongDB数据库来记录用户的行为，一切的数据爬取自豆瓣（可能因时间问题导致爬取方法不再适用）

GUI界面：
  本次的UI设计使用了GUI库PyQt5。项目考虑了一个推荐系统基本的功能，包括基础的登录提示界面、登录主界面、电影查询界面、电影详情以及评分界面；同时也考虑到了冷启动问题，设置了新用户注册界面、新用户登陆选择标签类型界面等等。
在登录界面有传统登录界面提示成功及失败的界面、在注册界面也有提示注册信息的相关显示（比如密码的首位不可以是0）。
而在主界面，项目提供了通过选择四种推荐算法来为用户做推荐，而且做了通过选择年代来展示对应年代的高分电影，并且提供了简单的用户主页界面（仅包括了用户的评价次数以及用户的喜好标签）；同样设置了搜索电影的入口，用户可以对电影进行搜索以便进入详情界面来进行打分（这里有一点不足的地方，项目的搜索必须输入电影的全部名称）

使用的四种算法：
    
    算法一：ItemCF
    分析用户的行为来计算物品之间的相似度，首先构建User-Item矩阵，将其转置为Item-User矩阵，并利用skilearn.metrics.pairwise库中的cosine_similarity()计算电影之间的余弦相似度矩阵。通过余弦相似度矩阵选择与用户喜爱的电影最相似的n个电影推荐给用户。
由于根据用户相似度矩阵返回的是电影的ID，我们把推荐的精确率作为一个评判标准。
把数据集平均分为互补的两部分，其中一部分用于构建相似度矩阵并推荐，另一部分中存储了部分用户喜欢的电影用于对照和精确率的计算。

    算法二：基于KNN的UserCF
    将一个用户对于全部电影的评分作为该用户的特征向量，使用KNN算法，对于输入的用户ID，首先选出与当前用户最相似的n个用户，之后选出这n个最相似用户看过的且当前用户没有看过的电影，最后在这些电影中选择出 平均评分最高的n部，推荐给用户。
算法的评估方面我们把推荐的精确率作为一个评判标准。
把数据集平均分为互补的两部分，其中一部分用于构建相似度矩阵并推荐，另一部分中存储了部分用户喜欢的电影用于对照和精确率的计算。

    算法三：Slope One
    Slope One 算法用于预测用户对于电影的评分。该算法的原理很简单：若用户X、Y和A都对Item1打了分，同时用户X、Y也对Item2打了分，那么根据Slope One算法，用户A对Item2可能打4-((5-3)+(4-3))/2 = 2.5分。Slope One算法在只有很少的数据的时候也能得到一个相对准确的推荐。
 
本程序在使用Slope One算法时，要想预测某一用户对某一电影A的评分的话，需要遍历获取该用户评分过的电影列表List（不包括A），若其他用户同时看过电影A和List中的电影，则按照上述Slope One算法加权计算评分，对List中的每部电影和数据集中的每个用户都进行如此操作，最后得到用户对电影A的预测评分。

    算法四：SVD矩阵分解
    SVD矩阵分解实现了将大量数据构造成的用户-电影评分矩阵降维处理并提取数据特征的过程。
首先对爬取的数据做处理，对爬取到的电影和用户以ID为区分做重新的编号，然后写入用户-电影-评分的矩阵，利用SVD分解的方式将这个4961×9881的矩阵进行降维（通过奇异值的方式，本次工程设置奇异值矩阵平方和80%对应的K阶矩阵为降维的输出结果），将矩阵分为左中右三个矩阵，也就是SVD分解的这个公式：
                                        A=UΣV^T
其中A为构建的完整矩阵，U为正交矩阵，它记录了各个电影直接相似的程度, Σ为对角矩阵，它记录了奇异值，也就是降维的基础；V^T记录了各个用户行为之间的相似程度。
在此之后我们通过余弦相似度的方法就可以通过用户评价相似度矩阵V^T来估计任何一个用户的评价，也可以利用电影相似度矩阵U来估计任何一部电影的实际评价。
这次工程选用了前一种的方法来对目标用户的未评价电影做预测，然后排序得出分数靠前的电影ID作为推荐系统的输出。
